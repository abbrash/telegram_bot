### <<<--------------------------------------------------------------------------------------------------->>> ###
### <<<-------------------------------------------- Libraries -------------------------------------------->>> ###
### <<<--------------------------------------------------------------------------------------------------->>> ###

import re, random, string, os, json
from datetime import datetime
from typing import Final
import pandas as pd
import numpy as np
from decouple import config
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, ContextTypes, CallbackContext, CallbackQueryHandler, ConversationHandler, MessageHandler, filters
from telegram.error import BadRequest


### <<<----------------------------------------------------------------------------------------------------------------->>> ###
### <<<-------------------------------------------- Constants and Variables -------------------------------------------->>> ###
### <<<----------------------------------------------------------------------------------------------------------------->>> ###

# Stages
START_ROUTES, END_ROUTES, SEND_IMG, PH_AIRDROP, PH_AIRDROP_SWAP, PH_AIRDROP_STAKE, PH_AIRDROP_UNSTAKE, EMAIL, MESS_HANDL = range(9)
LINEA_SURGE_AIRDROP, LINEA_SURGE_AIRDROP_STAKE, LINEA_SURGE_AIRDROP_UNSTAKE = range(9,12)


global first_time_loop_ph_swap, first_time_loop_ph_stake, first_time_loop_ph_unstake 
global current_index_ph_swap, current_index_ph_stake, current_index_ph_unstake
first_time_loop_ph_swap = True
first_time_loop_ph_stake = True
first_time_loop_ph_unstake = True
current_index_ph_swap = 0
current_index_ph_stake = 0
current_index_ph_unstake = 0

global first_time_loop_linea_surge_stake, first_time_loop_linea_surge_unstake
global current_index_linea_surge_stake, current_index_linea_surge_unstake
first_time_loop_linea_surge_stake = True
first_time_loop_linea_surge_unstake = True
current_index_linea_surge_stake = 0
current_index_linea_surge_unstake = 0


# Assuming you have a global dictionary to store message IDs
message_ids = {}

global chat_id
chat_id = None


### <<<-------------------------------------------------------------------------------------------------------->>> ###
### <<<-------------------------------------------- Sync Functions -------------------------------------------->>> ### 
### <<<-------------------------------------------------------------------------------------------------------->>> ###


# Define the path to save CSV file
data_file_add = 'data_base.csv'

# Define the path to save CSV file using os.getcwd() to get the current working directory
data_file_path = os.path.join(os.getcwd(), 'data_base.csv')

# Function to save email data to CSV
def save_email_data(df):
    df.to_csv(data_file_path, index=False)

# Function to load email data from CSV
def load_data_base():
    if os.path.exists(data_file_add):
        return pd.read_csv(data_file_add)
    else:
        return pd.DataFrame(columns=['ch_user_id', 'tel_user_name', 'tel_user_id', 'email_id', 'date'])

# Check if the email is already registered
def is_email(input_str):
    # Regular expression pattern for email validation
    email_pattern = r'^[\w\.-]+@[a-zA-Z\d\.-]+\.[a-zA-Z]{2,}$'
    # Using re.match to check if the input string matches the email pattern
    if re.match(email_pattern, input_str):
        return True
    else:
        return False

def gen_uniq_channel_id(existing_ids):
    """
    Generate a unique 10-digit channel ID.
    
    :param existing_ids: A set of existing channel IDs
    :return: A unique 10-digit channel ID
    """
    while True:
        # Generate a random 10-digit ID
        channel_id = ''.join(random.choices(string.digits, k=10))
        # Check if this ID is unique
        if channel_id not in existing_ids:
            return channel_id



### <<<--------------------------------------------------------------------------------------------------------->>> ###
### <<<--------------------------------------------------------------------------------------------------------->>> ###
### <<<-------------------------------------------- Async Functions -------------------------------------------->>> ###
### <<<--------------------------------------------------------------------------------------------------------->>> ###
### <<<--------------------------------------------------------------------------------------------------------->>> ###


# Log errors
async def error(update: Update, context: ContextTypes.DEFAULT_TYPE):
    print(f'Update {update} caused error {context.error}')


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    
    tel_user_id = update.effective_user.id

    if tel_user_id in data_base['tel_user_id'].values:
        tel_user_name = data_base[data_base['tel_user_id'] == tel_user_id]['tel_user_name'].values[0]
        print_txt = f"Hello my Fren, {tel_user_name}"

        keyboard = [
            [InlineKeyboardButton("ÿµÿ±ÿßŸÅ€å‚ÄåŸáÿß€å ÿß€åÿ±ÿßŸÜ€å  üí±üáÆüá∑", callback_data="local_exchange")],
            [InlineKeyboardButton("ÿµÿ±ÿßŸÅ€å‚ÄåŸáÿß€å ÿÆÿßÿ±ÿ¨€å üí±üåê", callback_data="global_exchange")],
            [InlineKeyboardButton("ÿß€åÿ±ÿØÿ±ÿßŸæ üöÄüéÅ", callback_data="air_drops")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
    else:
        keyboard = [
            [InlineKeyboardButton("ÿ´ÿ®ÿ™ ŸÜÿßŸÖ", callback_data="submit_email")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        print_txt = "ÿ®Ÿá ⁄©ÿßŸÜÿßŸÑ ⁄©ÿ±€åŸæÿ™€å⁄© ÿÆŸàÿ¥ ÿ¢ŸÖÿØ€åÿØ:"

    if update.message:
        await update.message.reply_text(text=print_txt, reply_markup=reply_markup)
    elif update.callback_query:
        query = update.callback_query
        current_index_ph_swap = 0 
        await query.answer()
        await query.edit_message_text(text=print_txt, reply_markup=reply_markup)

    return START_ROUTES


async def start_over(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Prompt same text & keyboard as `start` does but not as new message"""
    query = update.callback_query
    await query.answer()

    tel_user_id = update.effective_user.id

    if tel_user_id in data_base['tel_user_id'].values:
        tel_user_name = data_base[data_base['tel_user_id'] == tel_user_id]['tel_user_name'].values[0]
        print_txt = f"Stay with us, {tel_user_name}"

        keyboard = [
            [InlineKeyboardButton("ÿµÿ±ÿßŸÅ€å‚ÄåŸáÿß€å ÿß€åÿ±ÿßŸÜ€å  üí±üáÆüá∑", callback_data="local_exchange")],
            [InlineKeyboardButton("ÿµÿ±ÿßŸÅ€å‚ÄåŸáÿß€å ÿÆÿßÿ±ÿ¨€å üí±üåê", callback_data="global_exchange")],
            [InlineKeyboardButton("ÿß€åÿ±ÿØÿ±ÿßŸæ üöÄüéÅ", callback_data="air_drops")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
    else:
        keyboard = [
            [InlineKeyboardButton("ÿ´ÿ®ÿ™ ŸÜÿßŸÖ", callback_data="submit_email")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        print_txt = "ÿ®Ÿá ⁄©ÿßŸÜÿßŸÑ ⁄©ÿ±€åŸæÿ™€å⁄© ÿÆŸàÿ¥ ÿ¢ŸÖÿØ€åÿØ:"

    try:
        # Try to edit the message text
        await query.edit_message_text(text=print_txt, reply_markup=reply_markup)
    except BadRequest:
        # If the message doesn't have text content, send a new message
        await query.message.reply_text(text=print_txt, reply_markup=reply_markup)

    return START_ROUTES


async def confirm_email(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    global data_base

    tel_user_id = update.effective_user.id
    message_text = update.effective_message.text.lower()

    if update.effective_user.name:
        tel_user_name = update.effective_user.name
    else:
        tel_user_name = "no_tel_user_name"

    print('email confirming is executed')

    if is_email(message_text):
        if message_text in data_base['email_id'].values:
            await context.bot.send_message(chat_id=update.effective_chat.id, 
                                           text="ÿ¢ÿØÿ±ÿ≥ ÿß€åŸÖ€åŸÑ Ÿàÿßÿ±ÿØ ÿ¥ÿØŸá ÿ™Ÿàÿ≥ÿ∑ ÿ¥ÿÆÿµ ÿØ€å⁄Øÿ±€å ÿ´ÿ®ÿ™ ÿ¥ÿØŸá ÿßÿ≥ÿ™ÿå ŸÑÿ∑ŸÅÿßŸã ÿ¢ÿØÿ±ÿ≥ ÿß€åŸÖ€åŸÑ ÿÆŸàÿØÿ™ÿßŸÜ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:")
        else:
            ch_user_id = gen_uniq_channel_id(data_base['ch_user_id'].values)
            new_user = {
                'ch_user_id': ch_user_id,
                'tel_user_name': tel_user_name,
                'tel_user_id': tel_user_id,
                'email_id': message_text,
                'date': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            }

            new_user = pd.DataFrame([new_user])

            # Update email data DataFrame
            data_base = pd.concat([data_base, new_user], ignore_index=True)
            save_email_data(data_base)

            # await context.bot.send_message(chat_id=update.effective_chat.id, text=f"New email address added with ID: {tel_user_id}")
            # Show the main menu instead of sending a message
            return await main_menu(update, context)
    else:
        await context.bot.send_message(chat_id=update.effective_chat.id, 
                                       text="ÿ¢ÿØÿ±ÿ≥ ÿß€åŸÖ€åŸÑ Ÿàÿßÿ±ÿØ ÿ¥ÿØŸá ŸÜÿßÿØÿ±ÿ≥ÿ™ ÿßÿ≥ÿ™ÿå ŸÑÿ∑ŸÅÿßŸã ÿØŸàÿ®ÿßÿ±Ÿá ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ€åÿØ:")


async def submit_email(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()
    text = """ŸÑÿ∑ŸÅÿßŸã ÿ¢ÿØÿ±ÿ≥ ÿß€åŸÖ€åŸÑ ÿÆŸàÿØ ÿ±ÿß Ÿàÿßÿ±ÿØ ÿßÿ±ÿ≥ÿßŸÑ ⁄©ŸÜ€åÿØ:"""
    await query.edit_message_text(text=text)
    return EMAIL

async def local_exchange(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()

    keyboard = [
        [InlineKeyboardButton("ÿµÿ±ÿßŸÅ€å ŸÜŸàÿ®€åÿ™⁄©ÿ≥ (Nobitex) ", url='https://nobitex.ir/signup/?refcode=1557073')],
        [InlineKeyboardButton("ÿµÿ±ÿßŸÅ€å ÿ®€åÿ™‚ÄåŸæ€åŸÜ (BitPin)", url='https://bitpin.ir/signup/?ref=aP0DtoVG')],
        [InlineKeyboardButton("ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å üè† ", callback_data="main_menu")]
    ]
    key_markup = InlineKeyboardMarkup(keyboard)
    text = """ÿ®ÿß ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≤ ŸÑ€åŸÜ⁄©‚ÄåŸáÿß€å ŸÇÿ±ÿßÿ±ÿØÿßÿØŸá ÿ¥ÿØŸá ÿØÿ± ÿß€åŸÜ ÿ®ÿÆÿ¥ ŸÖ€å‚Äåÿ™ŸàÿßŸÜ€åÿØ ÿØÿ± ÿµÿ±ÿßŸÅ€å‚ÄåŸáÿß€å Ÿæ€åÿ¥ŸÜŸáÿßÿØ€å ÿ´ÿ®ÿ™‚ÄåŸÜÿßŸÖ ⁄©ŸÜ€åÿØ. 
ÿ¢ŸÖŸàÿ≤ÿ¥ ÿ´ÿ®ÿ™‚ÄåŸÜÿßŸÖ ÿØÿ± Ÿáÿ± €å⁄© ÿßÿ≤ ÿµÿ±ÿßŸÅ€å‚ÄåŸáÿß ÿ®Ÿá ÿ≤ŸàÿØ€å ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å ÿÆŸàÿßŸáÿØ ÿ¥ÿØ.
"""
    await query.edit_message_text(
        text=text,
        reply_markup=key_markup
    )
    return START_ROUTES

async def global_exchange(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()

    keyboard = [
        [InlineKeyboardButton("ÿµÿ±ÿßŸÅ€å ÿ®€åŸÜ⁄©‚Äåÿß⁄©ÿ≥ (BingX)", url='https://bingx.com/invite/NLQIKZI2')],
        [InlineKeyboardButton("ÿµÿ±ÿßŸÅ€å ⁄©Ÿà€åŸÜ⁄©ÿ≥ (CoinEx)", url='https://www.coinex.com/register?refer_code=s95m7')],
        [InlineKeyboardButton("ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å üè† ", callback_data="main_menu")]
    ]
    key_markup = InlineKeyboardMarkup(keyboard)

    text = """ÿ®ÿß ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≤ ŸÑ€åŸÜ⁄©‚ÄåŸáÿß€å ŸÇÿ±ÿßÿ±ÿØÿßÿØŸá ÿ¥ÿØŸá ÿØÿ± ÿß€åŸÜ ÿ®ÿÆÿ¥ ŸÖ€å‚Äåÿ™ŸàÿßŸÜ€åÿØ ÿØÿ± ÿµÿ±ÿßŸÅ€å‚ÄåŸáÿß€å Ÿæ€åÿ¥ŸÜŸáÿßÿØ€å ÿ´ÿ®ÿ™‚ÄåŸÜÿßŸÖ ⁄©ŸÜ€åÿØ. 
ÿ¢ŸÖŸàÿ≤ÿ¥ ÿ´ÿ®ÿ™‚ÄåŸÜÿßŸÖ ÿØÿ± Ÿáÿ± €å⁄© ÿßÿ≤ ÿµÿ±ÿßŸÅ€å‚ÄåŸáÿß ÿ®Ÿá ÿ≤ŸàÿØ€å ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å ÿÆŸàÿßŸáÿØ ÿ¥ÿØ.
"""
    await query.edit_message_text(
        text=text,
        reply_markup=key_markup
    )
    return START_ROUTES


async def main_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:

    if update.message:
        # Handle text messages
        return await start(update, context)
    elif update.callback_query:
        # Handle callback queries
        query = update.callback_query
        await query.answer()
        return await start_over(update, context)
    else:
        # Handle other update types (not expected)
        return END_ROUTES


### <<<-------------------------------------------- Phantom AirDrop -------------------------------------------->>> ###
### << *** Phantom AirDrop - Swap *** >>> ###

async def air_drop_phantom_swap(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    await query.answer()

    global current_index_ph_swap, first_time_loop_ph_swap, message_ids
    global chat_id

    print(f"Current index: {current_index_ph_swap}")

    # Check if query.data is a digit
    if query.data.isdigit():
        if first_time_loop_ph_swap:
            current_index_ph_swap = 0
            first_time_loop_ph_swap = False
        else:
            current_index_ph_swap = int(query.data)
    elif query.data == "phantom_swap":
        # Reset current_index when "air_drop_01" is clicked
        current_index_ph_swap = 0
        first_time_loop_ph_swap = False

    # Use img_add to dynamically generate the image filename based on the current index
    image_directory = 'img/airdrop/phantom_wallet/swap'
    img_add = image_directory
    image_filename = f'{image_directory}/{str(current_index_ph_swap + 1).zfill(2)}.png'

    # Ensure current_index stays within the bounds of available images
    current_index_ph_swap = max(
        0, min(current_index_ph_swap, len(os.listdir(img_add)) - 1))
    

    # Define your list of captions here
    captions_list = [
        """ÿØÿ± ÿ®ÿÆÿ¥ ŸÜÿ¥ÿßŸÜ‚ÄåÿØÿßÿØŸá ÿ¥ÿØŸáÿå ŸÖŸÇÿØÿßÿ± ŸÖŸàÿ¨ŸàÿØ€å ÿ≥ŸàŸÑÿßŸÜÿß(SOL) ÿØÿ± ⁄©€åŸÅ ŸæŸàŸÑ ÿ¥ŸÖÿß ŸÜŸÖÿß€åÿ¥ ÿØÿßÿØŸá ÿ¥ÿØŸá ÿßÿ≥ÿ™.
        ÿ±Ÿà€å ÿ¢ŸÜ ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ.
        """,
        """ÿ±Ÿà€å ⁄Øÿ≤€åŸÜŸá ÿ≥ŸàÿßŸæ (Swap) ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ.""",
        """ÿØÿ± ÿß€åŸÜÿ¨ÿß ÿ®ÿß€åÿØ ÿ™Ÿà⁄©ŸÜ€å ⁄©Ÿá ÿ≥ŸàŸÑÿßŸÜÿß ÿ®Ÿá ÿ¢ŸÜ ÿ™ÿ®ÿØ€åŸÑ ŸÖ€å‚Äåÿ¥ŸàÿØ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ. 
ÿ±Ÿà€å ÿ®ÿÆÿ¥ ŸÖÿ¥ÿÆÿµ ÿ¥ÿØŸá ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ.
        """,
        """ÿ™Ÿà⁄©ŸÜ USDC ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ.""",
        """
1Ô∏è‚É£  ŸÖŸÇÿØÿßÿ± ÿ≥ŸàŸÑÿßŸÜÿß€å€å ⁄©Ÿá ŸÖ€å‚ÄåÿÆŸàÿßŸá€åÿØ ÿ™ÿ®ÿØ€åŸÑ ⁄©ŸÜ€åÿØ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ.
2Ô∏è‚É£  ÿ®ÿµŸàÿ±ÿ™ ÿÆŸàÿØ⁄©ÿßÿ± ŸÖ€åÿ≤ÿßŸÜ USDC ÿØÿ±€åÿßŸÅÿ™€å ŸÜŸÖÿß€åÿ¥ ÿØÿßÿØŸá ŸÖ€å‚Äåÿ¥ŸàÿØ.
3Ô∏è‚É£  ÿ±Ÿà€å ÿØ⁄©ŸÖŸá Review Order ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ. 
""",
        """
1Ô∏è‚É£ ŸÖ€åÿ≤ÿßŸÜ ⁄©ÿßÿ±ŸÖÿ≤ÿØ ÿ™ÿ±ÿß⁄©ŸÜÿ¥ ŸÜŸÖÿß€åÿ¥ ÿØÿßÿØŸá ŸÖ€å‚Äåÿ¥ŸàÿØ.
2Ô∏è‚É£ ÿ±Ÿà€å ÿØ⁄©ŸÖŸá Swap ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ.
"""
        ]  

    # Construct caption with current index and total number of photos
    caption = captions_list[current_index_ph_swap]

    # Construct InlineKeyboardMarkup based on current message index
    buttons = []
    if current_index_ph_swap == 0:
        buttons = [
                [InlineKeyboardButton("‚û°Ô∏è ÿ®ÿπÿØ€å", callback_data=str(current_index_ph_swap + 1))],
                [InlineKeyboardButton("ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿß€åÿ±ÿØÿ±ÿßŸæ ŸÅÿßŸÜÿ™ŸàŸÖ üè†‚¨ÖÔ∏è ", callback_data="air_drop_phantom_menu_over")]
    ]
    elif current_index_ph_swap == len(os.listdir(img_add)) - 1:
        buttons = [
                [InlineKeyboardButton("üéâü•≥ ÿ™ÿßŸÖÿßŸÖ!", callback_data="air_drop_phantom_menu_over")],
                [InlineKeyboardButton("ŸÇÿ®ŸÑ€å ‚¨ÖÔ∏è", callback_data=str(current_index_ph_swap - 1))]
    ]
    else:
        buttons = [
                [InlineKeyboardButton("ŸÇÿ®ŸÑ€å ‚¨ÖÔ∏è", callback_data=str(current_index_ph_swap - 1)),
                InlineKeyboardButton("‚û°Ô∏è ÿ®ÿπÿØ€å", callback_data=str(current_index_ph_swap + 1))]
        ]

    reply_markup = InlineKeyboardMarkup(buttons)

    # Send the current photo with caption and navigation buttons
    chat_id = update.effective_chat.id

    with open(image_filename, 'rb') as photo:
        sent_photo = await context.bot.send_photo(
            chat_id=chat_id,
            photo=photo,
            caption=caption,
            reply_markup=reply_markup
        )
        
        # Store the message ID
        if chat_id not in message_ids:
            message_ids[chat_id] = []           # initialize a list to store further information
        message_ids[chat_id].append(sent_photo.message_id)
        
        # Delete the previous photo if it exists
        if len(message_ids.get(chat_id, [])) > 1:  # Use.get() method to avoid KeyError if chat_id not found
            await context.bot.delete_message(chat_id=chat_id, message_id=message_ids[chat_id][0])
            message_ids[chat_id].pop(0)

    return PH_AIRDROP_SWAP


### << *** Phantom AirDrop - Stake *** >>> ###

async def air_drop_phantom_stake(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()

    global current_index_ph_stake, first_time_loop_ph_stake
    global chat_id

    print(f"Current index: {current_index_ph_stake}")

    # Check if query.data is a digit
    if query.data.isdigit():
        if first_time_loop_ph_stake:
            current_index_ph_stake = 0
            first_time_loop_ph_stake = False
        else:
            current_index_ph_stake = int(query.data)
    elif query.data == "phantom_stake":
        # Reset current_index when "air_drop_01" is clicked
        current_index_ph_stake = 0
        first_time_loop_ph_stake = False

    # Use img_add to dynamically generate the image filename based on the current index
    image_directory = 'img/airdrop/phantom_wallet/stake'
    img_add = image_directory
    image_filename = f'{image_directory}/{str(current_index_ph_stake + 1).zfill(2)}.png'

    # Ensure current_index stays within the bounds of available images
    current_index_ph_stake = max(
        0, min(current_index_ph_stake, len(os.listdir(img_add)) - 1))


    # Define your list of captions here
    captions_list = [
        """ÿØÿ± ÿ®ÿÆÿ¥ ŸÜÿ¥ÿßŸÜ‚ÄåÿØÿßÿØŸá ÿ¥ÿØŸáÿå ŸÖŸÇÿØÿßÿ± ŸÖŸàÿ¨ŸàÿØ€å ÿ≥ŸàŸÑÿßŸÜÿß (SOL) ÿØÿ± ⁄©€åŸÅ ŸæŸàŸÑ ÿ¥ŸÖÿß ŸÜŸÖÿß€åÿ¥ ÿØÿßÿØŸá ÿ¥ÿØŸá ÿßÿ≥ÿ™.
ÿ±Ÿà€å ÿ¢ŸÜ ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ.
""",
"""ÿ®ÿ±ÿß€å ÿßÿ≥ÿ™€å⁄© ⁄©ÿ±ÿØŸÜ ÿ≥ŸàŸÑÿßŸÜÿßÿå ÿ±Ÿà€å ÿ®ÿÆÿ¥ ŸÖÿ¥ÿÆÿµ ÿ¥ÿØŸá ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ.""",
"""ÿßÿ≤ ŸÖ€åÿßŸÜ ⁄Øÿ≤€åŸÜŸá‚ÄåŸáÿß€å ŸÜŸÖÿß€åÿ¥ ÿØÿßÿØŸá ÿ¥ÿØŸáÿå Phantom Validator ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ.""",
"""
1Ô∏è‚É£ ŸÖŸÇÿØÿßÿ± ÿ≥ŸàŸÑÿßŸÜÿß€å ŸÖŸàÿ±ÿØ ŸÜÿ∏ÿ± ÿ±ÿß ÿ®ÿ±ÿß€å ÿßÿ≥ÿ™€å⁄© ⁄©ÿ±ÿØŸÜ ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ.
2Ô∏è‚É£ ÿ±Ÿà€å ⁄Øÿ≤€åŸÜŸá Stake ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ.
""",
        """ŸÖŸÜÿ™ÿ∏ÿ± ÿ®ŸÖÿßŸÜ€åÿØ ÿ™ÿß ÿ≠ÿ≥ÿßÿ® ÿßÿ≥ÿ™€å⁄© ÿ®ÿ±ÿß€å ÿ¥ŸÖÿß ÿß€åÿ¨ÿßÿØ ÿ¥ŸàÿØ.
‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è ÿß⁄Øÿ± ÿ®ÿß Ÿæ€åÿ∫ÿßŸÖ ÿÆÿ∑ÿß ŸÖŸàÿßÿ¨Ÿá ÿ¥ÿØ€åÿØ ÿØŸàÿ®ÿßÿ±Ÿá ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ€åÿØ.
""",
"""ÿØÿ± ÿß€åŸÜ ÿ≠ÿßŸÑÿ™ ÿ≥ŸàŸÑÿßŸÜÿß€å ÿßÿ±ÿ≥ÿßŸÑ ÿ¥ÿØŸá ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿßÿ≥ÿ™€å⁄© ÿ¥ÿØŸá ÿßÿ≥ÿ™.""",
"""ÿß⁄Øÿ± ÿ™ŸÖÿßŸÖ ŸÖÿ±ÿßÿ≠ŸÑ ÿ±ÿß ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿßŸÜÿ¨ÿßŸÖ ÿØÿßÿØŸá ÿ®ÿßÿ¥€åÿØÿå ÿØÿ± ÿµÿ≠ŸÅŸá ÿßŸàŸÑ ⁄©€åŸÅ ŸæŸàŸÑÿ™ÿßŸÜÿå ÿ≠ÿ≥ÿßÿ® ÿßÿ≥ÿ™€å⁄© ÿ≥ŸàŸÑÿßŸÜÿß ŸÜŸÖÿß€åÿ¥ ÿØÿßÿØŸá ŸÖ€å‚Äåÿ¥ŸàÿØ. 
ÿ±Ÿà€å ÿ¢ŸÜ ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ.
""",
"""ŸÅÿπÿßŸÑ‚Äåÿ¥ÿØŸÜ ÿ≠ÿ≥ÿßÿ® ÿ¥ŸÖÿß ⁄©ŸÖ€å ÿ≤ŸÖÿßŸÜ ŸÖ€å‚Äåÿ®ÿ±ÿØ. """,
"""Ÿæÿ≥ ÿßÿ≤ ÿß€åŸÜ⁄©Ÿá ÿ≠ÿ≥ÿßÿ®ÿ™ÿßŸÜ ŸÅÿπÿßŸÑ ÿ¥ÿØÿå ⁄Øÿ≤€åŸÜŸá ÿ≥ÿ®ÿ≤ ÿ±ŸÜ⁄Ø Active ÿ®ÿ±ÿß€å ÿ¥ŸÖÿß ŸÜŸÖÿß€åÿ¥ ÿØÿßÿØŸá ŸÖ€å‚Äåÿ¥ŸàÿØ."""
        ]  

    # Construct caption with current index and total number of photos
    caption = captions_list[current_index_ph_stake]

    # Construct InlineKeyboardMarkup based on current message index
    buttons = []
    if current_index_ph_stake == 0:
        buttons = [
                [InlineKeyboardButton("‚û°Ô∏è ÿ®ÿπÿØ€å", callback_data=str(current_index_ph_stake + 1))],
                [InlineKeyboardButton("ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿß€åÿ±ÿØÿ±ÿßŸæ ŸÅÿßŸÜÿ™ŸàŸÖ üè†‚¨ÖÔ∏è ", callback_data="air_drop_phantom_menu_over")]
    ]
    elif current_index_ph_stake == len(os.listdir(img_add)) - 1:
        buttons = [
                [InlineKeyboardButton("üéâü•≥ ÿ™ÿßŸÖÿßŸÖ!", callback_data="air_drop_phantom_menu_over")],
                [InlineKeyboardButton("ŸÇÿ®ŸÑ€å ‚¨ÖÔ∏è", callback_data=str(current_index_ph_stake - 1))]
    ]
    else:
        buttons = [
                [InlineKeyboardButton("ŸÇÿ®ŸÑ€å ‚¨ÖÔ∏è", callback_data=str(current_index_ph_stake - 1)),
                InlineKeyboardButton("‚û°Ô∏è ÿ®ÿπÿØ€å", callback_data=str(current_index_ph_stake + 1))]
        ]

    reply_markup = InlineKeyboardMarkup(buttons)

    # Send the current photo with caption and navigation buttons
    chat_id = update.effective_chat.id

    with open(image_filename, 'rb') as photo:
        sent_photo = await context.bot.send_photo(
            chat_id=chat_id,
            photo=photo,
            caption=caption,
            reply_markup=reply_markup
        )

        # Store the message ID
        if chat_id not in message_ids:
            # initialize a list to store further information
            message_ids[chat_id] = []
        message_ids[chat_id].append(sent_photo.message_id)

        # Delete the previous photo if it exists
        # Use.get() method to avoid KeyError if chat_id not found
        if len(message_ids.get(chat_id, [])) > 1:
            await context.bot.delete_message(chat_id=chat_id, message_id=message_ids[chat_id][0])
            message_ids[chat_id].pop(0)

    return PH_AIRDROP_STAKE


### << *** Phantom AirDrop - Unstake *** >>> ###

async def air_drop_phantom_unstake(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()

    global current_index_ph_unstake, first_time_loop_ph_unstake
    global chat_id

    print(f"Current index: {current_index_ph_unstake}")

    # Check if query.data is a digit
    if query.data.isdigit():
        if first_time_loop_ph_unstake:
            current_index_ph_unstake = 0
            first_time_loop_ph_unstake = False
        else:
            current_index_ph_unstake = int(query.data)
    elif query.data == "phantom_unstake":
        # Reset current_index when "air_drop_01" is clicked
        current_index_ph_unstake = 0
        first_time_loop_ph_unstake = False

    # Use img_add to dynamically generate the image filename based on the current index
    image_directory = 'img/airdrop/phantom_wallet/unstake'
    img_add = image_directory
    image_filename = f'{image_directory}/{str(current_index_ph_unstake + 1).zfill(2)}.png'

    # Ensure current_index stays within the bounds of available images
    current_index_ph_unstake = max(
        0, min(current_index_ph_unstake, len(os.listdir(img_add)) - 1))

    # Define your list of captions here
    captions_list = [
"""Ÿæÿ≥ ÿßÿ≤ ŸÅÿπÿßŸÑ‚Äåÿ≥ÿßÿ≤€å ÿ≠ÿ≥ÿßÿ® ÿßÿ≥ÿ™€å⁄© ÿ≥ŸàŸÑÿßŸÜÿßÿå ŸÖ€å‚Äåÿ™ŸàÿßŸÜ€åÿØ ÿ®ÿ±ÿß€å ÿ®ÿ±ÿØÿßÿ¥ÿ™ ŸæŸàŸÑ€å ⁄©Ÿá ÿßÿ≥ÿ™€å⁄© ⁄©ÿ±ÿØŸá‚Äåÿß€åÿØ ÿßŸÇÿØÿßŸÖ ⁄©ŸÜ€åÿØ. 
ÿ®ÿ±ÿß€å ÿß€åŸÜ ŸÖŸÜÿ∏Ÿàÿ± ÿØÿ± ÿ®ÿÆÿ¥ ŸÜÿ¥ÿßŸÜ‚ÄåÿØÿßÿØŸá ÿ¥ÿØŸáÿå ŸÖŸÇÿØÿßÿ± ŸÖŸàÿ¨ŸàÿØ€å ÿ≥ŸàŸÑÿßŸÜÿß (SOL) ÿØÿ± ⁄©€åŸÅ ŸæŸàŸÑ ÿ¥ŸÖÿß ŸÜŸÖÿß€åÿ¥ ÿØÿßÿØŸá ÿ¥ÿØŸá ÿßÿ≥ÿ™.
ÿ±Ÿà€å ÿ¢ŸÜ ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ.
""",
"""ÿ±Ÿà€å ⁄Øÿ≤€åŸÜŸá Unstake ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ.""",
"""ÿØÿ± ÿß€åŸÜ ÿ≠ÿßŸÑÿ™ ŸÅÿ±ÿ¢€åŸÜÿØ ÿ∫€åÿ±ŸÅÿπÿßŸÑ‚Äåÿ≥ÿßÿ≤€å ÿ≠ÿ≥ÿßÿ® ÿßÿ≥ÿ™€å⁄© ÿ¥ŸÖÿß ÿ¢ÿ∫ÿßÿ≤ ŸÖ€å‚Äåÿ¥ŸàÿØ.""",
"""Ÿæÿ≥ ÿßÿ≤ ŸÜŸÖÿß€åÿ¥ ÿß€åŸÜ ÿµŸÅÿ≠Ÿáÿå ÿ≠ÿ≥ÿßÿ® ÿßÿ≥ÿ™€å⁄© ÿ¥ŸÖÿß ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ∫€åÿ±ŸÅÿπÿßŸÑ ÿ¥ÿØŸá ÿßÿ≥ÿ™.
ÿ±Ÿà€å ⁄Øÿ≤€åŸÜŸá Close ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ.
""",
        """ÿØÿ± ÿß€åŸÜ ÿ≠ÿßŸÑÿ™ ÿ®ÿß Ÿàÿ±ŸàÿØ ÿ®Ÿá ÿ≠ÿ≥ÿßÿ® ÿßÿ≥ÿ™€å⁄© ÿ≥ŸàŸÑÿßŸÜÿßÿå ÿπÿ®ÿßÿ±ÿ™ Deactivating ŸÜŸÖÿß€åÿ¥ ÿØÿßÿØŸá ŸÖ€å‚Äåÿ¥ŸàÿØ.
‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è ÿØŸÇÿ™ ⁄©ŸÜ€åÿØ ÿß€åŸÜ ŸÖÿ±ÿ≠ŸÑŸá ŸÖŸÖ⁄©ŸÜ ÿßÿ≥ÿ™ ÿ™ÿß ⁄ÜŸÜÿØ ÿ±Ÿàÿ≤ ÿ∑ŸàŸÑ ÿ®⁄©ÿ¥€åÿØ.
""",
"""ÿ®ÿß ŸÜŸÖÿß€åÿ¥ Ÿàÿß⁄òŸá ŸÇÿ±ŸÖÿ≤ ÿ±ŸÜ⁄Ø Inactive ÿ≠ÿ≥ÿßÿ® ÿßÿ≥ÿ™€å⁄© ÿ≥ŸàŸÑÿßŸÜÿß ÿ¥ŸÖÿß ÿ®Ÿá ÿµŸàÿ±ÿ™ ⁄©ÿßŸÖŸÑ ÿ∫€åÿ±ŸÅÿπÿßŸÑ ÿ¥ÿØŸá ÿßÿ≥ÿ™.
ÿß⁄©ŸÜŸàŸÜ ŸÖ€å‚Äåÿ™ŸàÿßŸÜ€åÿØ ŸæŸàŸÑ ÿÆŸàÿØ ÿ±ÿß ÿ®ÿ±ÿØÿßÿ¥ÿ™ ⁄©ŸÜ€åÿØ. 
ÿ±Ÿà€å ÿ¢ŸÜ ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ.
""",
"""ÿ±Ÿà€å ⁄Øÿ≤€åŸÜŸá Withdraw Stake ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ.""",
"""ŸÅÿ±ÿ¢€åŸÜÿØ ÿ®ÿ±ÿØÿßÿ¥ÿ™ ŸæŸàŸÑ ÿ¥ŸÖÿß ÿ¢ÿ∫ÿßÿ≤ ÿ¥ÿØŸá ÿßÿ≥ÿ™. 
‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è ÿß⁄Øÿ± ÿ®ÿß Ÿæ€åÿ∫ÿßŸÖ ÿÆÿ∑ÿß ŸÖŸàÿßÿ¨Ÿá ÿ¥ÿØ€åÿØ ÿØŸàÿ®ÿßÿ±Ÿá ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ€åÿØ.
""",
"""ŸæŸàŸÑ ÿ¥ŸÖÿß ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ®ÿ±ÿØÿßÿ¥ÿ™ ÿ¥ÿØ Ÿà ÿ®Ÿá ŸÖŸàÿ¨ŸàÿØ€å ÿ≥ŸàŸÑÿßŸÜÿß ÿØÿ± ⁄©€åŸÅ ŸæŸàŸÑÿ™ÿßŸÜ ÿßÿ∂ÿßŸÅŸá ⁄Øÿ±ÿØ€åÿØ. """
        ]  

    # Construct caption with current index and total number of photos
    caption = captions_list[current_index_ph_unstake]

    # Construct InlineKeyboardMarkup based on current message index
    buttons = []
    if current_index_ph_unstake == 0:
        buttons = [
                [InlineKeyboardButton("‚û°Ô∏è ÿ®ÿπÿØ€å", callback_data=str(current_index_ph_unstake + 1))],
                [InlineKeyboardButton("ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿß€åÿ±ÿØÿ±ÿßŸæ ŸÅÿßŸÜÿ™ŸàŸÖ üè†‚¨ÖÔ∏è ", callback_data="air_drop_phantom_menu_over")]
    ]
    elif current_index_ph_unstake == len(os.listdir(img_add)) - 1:
        buttons = [
                [InlineKeyboardButton("üéâü•≥ ÿ™ÿßŸÖÿßŸÖ!", callback_data="air_drop_phantom_menu_over")],
                [InlineKeyboardButton("ŸÇÿ®ŸÑ€å ‚¨ÖÔ∏è", callback_data=str(current_index_ph_unstake - 1))]
    ]
    else:
        buttons = [
                [InlineKeyboardButton("ŸÇÿ®ŸÑ€å ‚¨ÖÔ∏è", callback_data=str(current_index_ph_unstake - 1)),
                 InlineKeyboardButton("‚û°Ô∏è ÿ®ÿπÿØ€å", callback_data=str(current_index_ph_unstake + 1))]
        ]

    reply_markup = InlineKeyboardMarkup(buttons)

    # Send the current photo with caption and navigation buttons
    chat_id = update.effective_chat.id

    with open(image_filename, 'rb') as photo:
        sent_photo = await context.bot.send_photo(
            chat_id=chat_id,
            photo=photo,
            caption=caption,
            reply_markup=reply_markup
        )

        # Store the message ID
        if chat_id not in message_ids:
            # initialize a list to store further information
            message_ids[chat_id] = []
        message_ids[chat_id].append(sent_photo.message_id)

        # Delete the previous photo if it exists
        # Use.get() method to avoid KeyError if chat_id not found
        if len(message_ids.get(chat_id, [])) > 1:
            await context.bot.delete_message(chat_id=chat_id, message_id=message_ids[chat_id][0])
            message_ids[chat_id].pop(0)

    return PH_AIRDROP_UNSTAKE


### <<<-------------------------------------------- Phantom AirDrop Sub-Menu -------------------------------------------->>> ###

async def air_drop_phantom_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    global chat_id

    # Delete the previous photo if it exists
    # Use.get() method to avoid KeyError if chat_id not found
    if len(message_ids.get(chat_id, [])) == 1:
        await context.bot.delete_message(chat_id=chat_id, message_id=message_ids[chat_id][0])
        message_ids[chat_id].pop(0)

    global current_index_ph_swap, first_time_loop_ph_swap
    current_index_ph_swap = 0
    first_time_loop_ph_swap = True

    global current_index_ph_stake, first_time_loop_ph_stake
    current_index_ph_stake = 0
    first_time_loop_ph_stake = True

    global current_index_ph_unstake, first_time_loop_ph_unstake
    current_index_ph_unstake = 0
    first_time_loop_ph_unstake = True

    keyboard = [
        [InlineKeyboardButton("1. ÿ≥ŸàÿßŸæ ⁄©ÿ±ÿØŸÜ (Swap) üíµüîÑ",
                              callback_data="phantom_swap")],
        [InlineKeyboardButton("2. ÿßÿ≥ÿ™€å⁄© ⁄©ÿ±ÿØŸÜ (Stake) üíµüí∞",
                              callback_data="phantom_stake")],
        [InlineKeyboardButton("3. ÿ¢ŸÜ‚Äåÿßÿ≥ÿ™€å⁄© ⁄©ÿ±ÿØŸÜ (Unstake) üíµüßæ",
                              callback_data="phantom_unstake")],
        [InlineKeyboardButton(
            "ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ‚¨ÖÔ∏è", callback_data="back_to_air_drop_menu")]
    ]
    key_markup = InlineKeyboardMarkup(keyboard)

    text = """
<b>ÿß€åÿ±ÿØÿ±ÿßŸæ ŸÅÿßŸÜÿ™ŸàŸÖ (Phantom) </b>

üîÑ ŸÜÿ≠ŸàŸá ŸÅÿπÿßŸÑ€åÿ™: 
ŸáŸÅÿ™⁄Ø€å €åÿß ŸÖÿßŸá€åÿßŸÜŸá

üíµ ŸÖŸàÿ¨ŸàÿØ€å ŸÖŸàÿ±ÿØ ŸÜ€åÿßÿ≤:
30 ÿ™ÿ™ÿ± 

üì∞ Ÿàÿ∂ÿπ€åÿ™ ÿß€åÿ±ÿØÿ±ÿßŸæ:
ÿßÿ≠ÿ™ŸÖÿßŸÑ€å

üìÖ ÿ™ÿßÿ±€åÿÆ ÿ™Ÿàÿ≤€åÿπ: 
ŸÜÿßŸÖÿ¥ÿÆÿµ

üìñ ÿ™Ÿàÿ∂€åÿ≠ÿßÿ™:
ÿ®ÿ±ÿß€å ÿ¥ÿ±⁄©ÿ™ ÿØÿ± ÿß€åÿ±ÿØÿ±ÿßŸæ ŸÅÿßŸÜÿ™ŸàŸÖÿå ŸÑÿ∑ŸÅÿßŸã ŸÖŸàÿßÿ±ÿØ ÿ≤€åÿ± ÿ±ÿß ÿ®Ÿá ÿ™ÿ±ÿ™€åÿ® ÿßŸÜÿ¨ÿßŸÖ ÿØŸá€åÿØ.
"""

    # Select an image to send
    # Replace with the actual path to your image
    image_filename = os.path.join('img', 'airdrop', 'phantom_wallet', 'phantom_wallet_img.jpg')

    # Send the image along with the text and buttons
    await context.bot.send_photo(
        chat_id=update.effective_chat.id,
        photo=open(image_filename, 'rb'),
        caption=text,
        reply_markup=key_markup,
        parse_mode="HTML"
    )

    return PH_AIRDROP


async def air_drop_phantom_menu_over(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    global chat_id

    # Delete the previous photo if it exists
    # Use.get() method to avoid KeyError if chat_id not found
    if len(message_ids.get(chat_id, [])) == 1:
        await context.bot.delete_message(chat_id=chat_id, message_id=message_ids[chat_id][0])
        message_ids[chat_id].pop(0)

    return PH_AIRDROP



### <<<-------------------------------------------- Linea Surge AirDrop -------------------------------------------->>> ###

async def air_drop_linea_surge_stake(update: Update, context: CallbackContext) -> int:
    query = update.callback_query
    await query.answer()

    global current_index_linea_surge_stake, first_time_loop_linea_surge_stake, message_ids
    global chat_id

    print(f"Current index: {current_index_linea_surge_stake}")

    # Check if query.data is a digit
    if query.data.isdigit():
        if first_time_loop_linea_surge_stake:
            current_index_linea_surge_stake = 0
            first_time_loop_linea_surge_stake = False
        else:
            current_index_linea_surge_stake = int(query.data)
    elif query.data == "linea_surge_stake":
        # Reset current_index when "air_drop_01" is clicked
        current_index_linea_surge_stake = 0
        first_time_loop_linea_surge_stake = False

    # Use img_add to dynamically generate the image filename based on the current index
    image_directory = 'img/airdrop/linea_surge/stake'
    img_add = image_directory
    image_filename = f'{image_directory}/{str(current_index_linea_surge_stake + 1).zfill(2)}.png'

    # Ensure current_index stays within the bounds of available images
    current_index_linea_surge_stake = max(
        0, min(current_index_linea_surge_stake, len(os.listdir(img_add)) - 1))
    

    # Define your list of captions here
    captions_list = [
        """ÿ®ÿß ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≤ ÿß€åŸÜ ŸÑ€åŸÜ⁄© Ÿàÿßÿ±ÿØ ÿ≥ÿß€åÿ™ SyncSwap ÿ¥Ÿà€åÿØ. 
1Ô∏è‚É£ ÿ±Ÿà€å ⁄Øÿ≤€åŸÜŸá Trade ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ.
2Ô∏è‚É£ ÿØÿ± ÿß€åŸÜ ÿ®ÿÆÿ¥ ÿ¢ÿØÿ±ÿ≥ ⁄©€åŸÅ ŸæŸàŸÑ ŸÜŸÖÿß€åÿ¥ ÿØÿßÿØŸá ŸÖ€å‚Äåÿ¥ŸàÿØ. 
‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è ÿß⁄Øÿ± ⁄Øÿ≤€åŸÜŸá Connect Wallet ÿ±ÿß ŸÖ€å‚Äåÿ®€åŸÜ€åÿØÿå ÿ±Ÿà€å ÿ¢ŸÜ ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ ÿ™ÿß ⁄©€åŸÅ ŸæŸàŸÑÿ™ÿßŸÜ ÿ®Ÿá ÿ≥ÿß€åÿ™ ŸàÿµŸÑ ÿ¥ŸàÿØ.
3Ô∏è‚É£ ÿ±Ÿà€å ÿß€åŸÜ ⁄Øÿ≤€åŸÜŸá ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ. 
4Ô∏è‚É£ ÿßÿ≤ ŸÖŸÜŸà€å ÿ®ÿßÿ≤ ÿ¥ÿØŸá ÿ¥ÿ®⁄©Ÿá Linea ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ. 
""",
"""
1Ô∏è‚É£ ÿ™Ÿà⁄©ŸÜ ETH ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ.
2Ô∏è‚É£ ÿ™Ÿà⁄©ŸÜ weETH ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ.
3Ô∏è‚É£ ŸÖŸÇÿØÿßÿ± ÿßÿ™ÿ±€åŸàŸÖ€å ⁄©Ÿá ŸÖ€å‚ÄåÿÆŸàÿßŸá€åÿØ ÿ®Ÿá weETH ÿ™ÿ®ÿØ€åŸÑ ⁄©ŸÜ€åÿØ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ. (ÿπÿØÿØ ŸÜŸàÿ¥ÿ™Ÿá ÿ¥ÿØŸá ÿØÿ± ⁄©ÿßÿØÿ± ⁄©Ÿà⁄Ü⁄©ÿå ŸÖÿπÿßÿØŸÑ ÿØŸÑÿßÿ±€å ETH ÿ±ÿß ŸÜÿ¥ÿßŸÜ ŸÖ€å‚ÄåÿØŸáÿØ.)
4Ô∏è‚É£ ŸÖŸÇÿØÿßÿ± ÿØÿ±€åÿßŸÅÿ™€å ÿ®ÿ±ÿß€å ÿ¥ŸÖÿß ŸÜŸÖÿß€åÿ¥ ÿØÿßÿØŸá ŸÖ€å‚Äåÿ¥ŸàÿØ. (ÿπÿØÿØ ŸÜŸàÿ¥ÿ™Ÿá ÿ¥ÿØŸá ÿØÿ± ⁄©ÿßÿØÿ± ⁄©Ÿà⁄Ü⁄©ÿå ŸÖÿπÿßÿØŸÑ ÿØŸÑÿßÿ±€å weETH ÿ±ÿß ŸÜÿ¥ÿßŸÜ ŸÖ€å‚ÄåÿØŸáÿØ.)

5Ô∏è‚É£ ÿπÿØÿØ ŸÜŸàÿ¥ÿ™Ÿá ÿ¥ÿØŸá ÿØÿ± ⁄©ÿßÿØÿ± ⁄©Ÿà⁄Ü⁄©ÿå ŸÖ€åÿ≤ÿßŸÜ ⁄©ÿßÿ±ŸÖÿ≤ÿØ ŸÖÿπÿßŸÖŸÑŸá ÿ±ÿß ŸÜŸÖÿß€åÿ¥ ŸÖ€å‚ÄåÿØŸáÿØ.
ÿß⁄Øÿ± ŸÖŸÇÿØÿßÿ± ⁄©ÿßÿ±ŸÖÿ≤ÿØ ŸÜŸÖÿß€åÿ¥ ÿØÿßÿØŸá ÿ¥ÿØŸá ÿØÿ± ÿ≠ÿØ ⁄ÜŸÜÿØ ÿ≥ŸÜÿ™ ÿßÿ≥ÿ™ (ÿØÿ± ÿß€åŸÜÿ¨ÿß 3 ÿ≥ŸÜÿ™)ÿå ÿ±Ÿà€å ÿØ⁄©ŸÖŸá Swap ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ. 
""",
"""
1Ô∏è‚É£ ŸÖŸÇÿØÿßÿ± ⁄©ÿßÿ±ŸÖÿ≤ÿØ ⁄©ŸÑ ÿ™ÿ±ÿß⁄©ŸÜÿ¥ ÿ±ÿß ŸÜŸÖÿß€åÿ¥ ŸÖ€å‚ÄåÿØŸáÿØ.
2Ô∏è‚É£ ÿßÿ±ÿ≤ÿ¥ ⁄©ŸÑ ÿ™ÿ±ÿß⁄©ŸÜÿ¥ (ŸÖŸÇÿØÿßÿ± ÿßÿ™ÿ±€åŸàŸÖ€å ⁄©Ÿá ŸÖ€å‚ÄåÿÆŸàÿßŸá€åÿØ ÿ™ÿ®ÿØ€åŸÑ ⁄©ŸÜ€åÿØ + ⁄©ÿßÿ±ŸÖÿ≤ÿØ ÿ™ÿ±ÿß⁄©ŸÜÿ¥) ÿ±ÿß ŸÜŸÖÿß€åÿ¥ ŸÖ€å‚ÄåÿØŸáÿØ.
3Ô∏è‚É£ ÿß⁄Øÿ± ŸÖŸÇÿØÿßÿ± ⁄©ÿßÿ±ŸÖÿ≤ÿØ ÿ™ÿ±ÿß⁄©ŸÜÿ¥ ⁄©ŸÖ ÿßÿ≥ÿ™ÿå ÿ±Ÿà€å ÿØ⁄©ŸÖŸá Confirm ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ. 
""",
"""ÿßÿ≤ ŸÜŸàÿßÿ± ÿ®ÿßŸÑÿß ÿ±Ÿà€å Pool ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ Ÿà ÿØÿ± ŸÖŸÜŸà€å ÿ®ÿßÿ≤ ÿ¥ÿØŸá Pools ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ.""",
"""ÿØÿ± ⁄©ÿßÿØÿ± ŸÖÿ¥ÿÆÿµ ÿ¥ÿØŸá ÿπÿ®ÿßÿ±ÿ™ weeth ÿ±ÿß ÿ¨ÿ≥ÿ™ÿ¨Ÿà ⁄©ŸÜ€åÿØ Ÿà ÿßÿ≤ ŸÖ€åÿßŸÜ ŸÜÿ™ÿß€åÿ¨ ÿ®Ÿá ÿØÿ≥ÿ™ ÿ¢ŸÖÿØŸá ÿßÿ≥ÿ™ÿÆÿ± ŸÜŸÇÿØ€åŸÜ⁄Ø€å ŸÖÿ±ÿ®Ÿàÿ∑ ÿ®Ÿá ETH/weETH ÿßÿ≤ ŸÜŸàÿπ Classic ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ.""",
"""
1Ô∏è‚É£ ÿ±Ÿà€å ⁄Øÿ≤€åŸÜŸá Deposit ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ.
2Ô∏è‚É£ ÿ™€å⁄© ŸÖÿ¥ÿÆÿµ ÿ¥ÿØŸá ÿ±ÿß ŸÅÿπÿßŸÑ ⁄©ŸÜ€åÿØ.
3Ô∏è‚É£ ŸÖŸÇÿØÿßÿ± weETH ⁄©Ÿá ŸÖ€å‚ÄåÿÆŸàÿßŸá€åÿØ Ÿàÿßÿ±€åÿ≤ ⁄©ŸÜ€åÿØ ÿ±ÿß ŸÖÿ¥ÿÆÿµ ⁄©ŸÜ€åÿØ. ÿØÿ± ÿß€åŸÜ ÿ≠ÿßŸÑÿ™ ÿ®ÿµŸàÿ±ÿ™ ÿÆŸàÿØ⁄©ÿßÿ±ÿå ŸÖŸÇÿØÿßÿ± ETH ŸÖÿπÿßÿØŸÑ ŸÜ€åÿ≤ ÿØÿ± ⁄©ÿßÿØÿ± Ÿæÿß€å€åŸÜ ŸÜŸÖÿß€åÿ¥ ÿØÿßÿØŸá ŸÖ€å‚Äåÿ¥ŸàÿØ.
4Ô∏è‚É£ ÿ±Ÿà€å ÿØ⁄©ŸÖŸá Unlock weETH ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ. 
""",
"""
1Ô∏è‚É£ ÿØÿ± ÿß€åŸÜ ÿ®ÿß€åÿØ ÿ®Ÿá ÿ≥ÿß€åÿ™ ÿ®ÿ±ÿß€å ÿ®ÿ±ÿØÿßÿ¥ÿ™ weETH ÿØÿ≥ÿ™ÿ±ÿ≥€å ÿØŸá€åÿØ. ŸÖŸÇÿØÿßÿ±€å ⁄©Ÿá ÿØÿ± ÿ®ÿÆÿ¥ 3 ŸÖÿ±ÿ≠ŸÑŸá ŸÇÿ®ŸÑ€å Ÿàÿßÿ±ÿØ ⁄©ÿ±ÿØ€åÿØ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ. (ÿ®ÿ±ÿß€å ÿßÿ∑ŸÖ€åŸÜÿßŸÜ ŸÖ€å‚Äåÿ™ŸàÿßŸÜ€åÿØ ⁄©ŸÖ€å ÿ®€åÿ¥ÿ™ÿ± Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ.) 
2Ô∏è‚É£ ÿ±Ÿà€å ÿØ⁄©ŸÖŸá Next ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ.
""",
"""
1Ô∏è‚É£ ⁄©ÿßÿ±ŸÖÿ≤ÿØ ÿ™ÿ±ÿß⁄©ŸÜÿ¥ ŸÜŸÖÿß€åÿ¥ ÿØÿßÿØŸá ÿ¥ÿØŸá ÿßÿ≥ÿ™. 
2Ô∏è‚É£ ÿß⁄Øÿ± ⁄©ÿßÿ±ŸÖÿ≤ÿØ ⁄©ŸÖ ÿßÿ≥ÿ™ÿå ÿ±Ÿà€å ÿØ⁄©ŸÖŸá Approve ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ.
""",
"""ÿ±Ÿà€å ÿØ⁄©ŸÖŸá Deposit ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ. """,
        """
1Ô∏è‚É£ ŸÖŸÇÿØÿßÿ± ⁄©ÿßÿ±ŸÖÿ≤ÿØ ⁄©ŸÑ ÿ™ÿ±ÿß⁄©ŸÜÿ¥ ÿ±ÿß ŸÜŸÖÿß€åÿ¥ ŸÖ€å‚ÄåÿØŸáÿØ.
2Ô∏è‚É£ ÿßÿ±ÿ≤ÿ¥ ⁄©ŸÑ ÿ™ÿ±ÿß⁄©ŸÜÿ¥ (ÿßÿ±ÿ≤ÿ¥ ÿØŸÑÿßÿ±€å ÿ™Ÿà⁄©ŸÜ‚ÄåŸáÿß€å€å ⁄©Ÿá ŸÖ€å‚ÄåÿÆŸàÿßŸá€åÿØ Ÿàÿßÿ±€åÿ≤ ⁄©ŸÜ€åÿØ + ⁄©ÿßÿ±ŸÖÿ≤ÿØ ÿ™ÿ±ÿß⁄©ŸÜÿ¥) ÿ±ÿß ŸÜŸÖÿß€åÿ¥ ŸÖ€å‚ÄåÿØŸáÿØ.
3Ô∏è‚É£ ÿß⁄Øÿ± ŸÖŸÇÿØÿßÿ± ⁄©ÿßÿ±ŸÖÿ≤ÿØ ÿ™ÿ±ÿß⁄©ŸÜÿ¥ ⁄©ŸÖ ÿßÿ≥ÿ™ÿå ÿ±Ÿà€å ÿØ⁄©ŸÖŸá Confirm ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ. 
"""
        ]  

    # Construct caption with current index and total number of photos
    caption = captions_list[current_index_linea_surge_stake]

    # Construct InlineKeyboardMarkup based on current message index
    buttons = []
    if current_index_linea_surge_stake == 0:
        buttons = [
                [InlineKeyboardButton("‚û°Ô∏è ÿ®ÿπÿØ€å", callback_data=str(current_index_linea_surge_stake + 1))],
                [InlineKeyboardButton("ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿß€åÿ±ÿØÿ±ÿßŸæ ŸÑ€åŸÜ€åÿß üè†‚¨ÖÔ∏è ", callback_data="air_drop_linea_surge_menu_over")]
    ]
    elif current_index_linea_surge_stake == len(os.listdir(img_add)) - 1:
        buttons = [
                [InlineKeyboardButton("üéâü•≥ ÿ™ÿßŸÖÿßŸÖ!", callback_data="air_drop_linea_surge_menu_over")],
                [InlineKeyboardButton("ŸÇÿ®ŸÑ€å ‚¨ÖÔ∏è", callback_data=str(current_index_linea_surge_stake - 1))]
    ]
    else:
        buttons = [
                [InlineKeyboardButton("ŸÇÿ®ŸÑ€å ‚¨ÖÔ∏è", callback_data=str(current_index_linea_surge_stake - 1)),
                 InlineKeyboardButton("‚û°Ô∏è ÿ®ÿπÿØ€å", callback_data=str(current_index_linea_surge_stake + 1))]
        ]

    reply_markup = InlineKeyboardMarkup(buttons)

    # Send the current photo with caption and navigation buttons
    chat_id = update.effective_chat.id

    with open(image_filename, 'rb') as photo:
        sent_photo = await context.bot.send_photo(
            chat_id=chat_id,
            photo=photo,
            caption=caption,
            reply_markup=reply_markup
        )
        
        # Store the message ID
        if chat_id not in message_ids:
            message_ids[chat_id] = []           # initialize a list to store further information
        message_ids[chat_id].append(sent_photo.message_id)
        
        # Delete the previous photo if it exists
        if len(message_ids.get(chat_id, [])) > 1:  # Use.get() method to avoid KeyError if chat_id not found
            await context.bot.delete_message(chat_id=chat_id, message_id=message_ids[chat_id][0])
            message_ids[chat_id].pop(0)

    return LINEA_SURGE_AIRDROP_STAKE



### << *** Phantom AirDrop - Stake *** >>> ###

async def air_drop_linea_surge_unstake(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()

    global current_index_linea_surge_unstake, first_time_loop_linea_surge_unstake
    global chat_id

    print(f"Current index: {current_index_linea_surge_unstake}")

    # Check if query.data is a digit
    if query.data.isdigit():
        if first_time_loop_linea_surge_unstake:
            current_index_linea_surge_unstake = 0
            first_time_loop_linea_surge_unstake = False
        else:
            current_index_linea_surge_unstake = int(query.data)
    elif query.data == "linea_surge_unstake":
        # Reset current_index when "air_drop_01" is clicked
        current_index_linea_surge_unstake = 0
        first_time_loop_linea_surge_unstake = False

    # Use img_add to dynamically generate the image filename based on the current index
    image_directory = 'img/airdrop/linea_surge/unstake'
    img_add = image_directory
    image_filename = f'{image_directory}/{str(current_index_linea_surge_unstake + 1).zfill(2)}.png'

    # Ensure current_index stays within the bounds of available images
    current_index_linea_surge_unstake = max(
        0, min(current_index_linea_surge_unstake, len(os.listdir(img_add)) - 1))


    # Define your list of captions here
    captions_list = [
        """ÿ®ÿ±ÿß€å ÿ®ÿ±ÿØÿßÿ¥ÿ™ ŸæŸàŸÑ ÿßÿ≤ ÿ≥ÿß€åÿ™ SyncSwap ÿß€åŸÜ ŸÖÿ±ÿßÿ≠ŸÑ ÿ±ÿß ÿßŸÜÿ¨ÿßŸÖ ÿØŸá€åÿØ.
ÿßÿ≤ ŸÜŸàÿßÿ± ÿ®ÿßŸÑÿß ÿ±Ÿà€å ⁄Øÿ≤€åŸÜŸá Pool ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ Ÿà ÿßÿ≤ ŸÖŸÜŸà€å ÿ®ÿßÿ≤ ÿ¥ÿØŸá Positionsÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ.
""",
"""ÿØÿ± ÿß€åŸÜÿ¨ÿß Position ŸÖÿ¥ÿÆÿµ ÿ¥ÿØŸá ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ.""",
"""
1Ô∏è‚É£ ÿ±Ÿà€å Withdraw ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ.
2Ô∏è‚É£ ÿ®ÿ±ÿß€å ÿ®ÿ±ÿØÿßÿ¥ÿ™ ⁄©ŸÑ ŸÖŸàÿ¨ŸàÿØ€åÿå ÿ±Ÿà€å Max ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ. (ŸÖ€å‚Äåÿ™ŸàÿßŸÜ€åÿØ ÿ®ÿµŸàÿ±ÿ™ ÿØÿ≥ÿ™€åÿå Ÿáÿ± ŸÖŸÇÿØÿßÿ±€å ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ.)
3Ô∏è‚É£ ⁄Øÿ≤€åŸÜŸá Balanced ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ.
""",
"""ÿ±Ÿà€å Unlock LP Token ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ.""",
"""
1Ô∏è‚É£ ÿØÿ± ÿß€åŸÜ ÿ®ÿß€åÿØ ÿ®Ÿá ÿ≥ÿß€åÿ™ ÿ®ÿ±ÿß€å ÿ®ÿ±ÿØÿßÿ¥ÿ™ weETH ÿØÿ≥ÿ™ÿ±ÿ≥€å ÿØŸá€åÿØ. ŸÖŸÇÿØÿßÿ±€å ⁄©Ÿá ÿØÿ± ŸÖÿ±ÿ≠ŸÑŸá ŸÇÿ®ŸÑ€å Ÿàÿßÿ±ÿØ ⁄©ÿ±ÿØ€åÿØ ÿ±ÿß ŸÖÿ¨ÿØÿØÿßŸã Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ. (ÿ®ÿ±ÿß€å ÿßÿ∑ŸÖ€åŸÜÿßŸÜ ŸÖ€å‚Äåÿ™ŸàÿßŸÜ€åÿØ ⁄©ŸÖ€å ÿ®€åÿ¥ÿ™ÿ± Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ.) 
2Ô∏è‚É£ ÿ±Ÿà€å Next ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ.
""",
"""
1Ô∏è‚É£ ⁄©ÿßÿ±ŸÖÿ≤ÿØ ÿ™ÿ±ÿß⁄©ŸÜÿ¥ ŸÜŸÖÿß€åÿ¥ ÿØÿßÿØŸá ÿ¥ÿØŸá ÿßÿ≥ÿ™.
2Ô∏è‚É£ ÿ±Ÿà€å Approve ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ.
""",
"""ÿ±Ÿà€å Withdraw Liquidity ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ.""",
"""
1Ô∏è‚É£ ⁄©ÿßÿ±ŸÖÿ≤ÿØ ÿ™ÿ±ÿß⁄©ŸÜÿ¥ ŸÜŸÖÿß€åÿ¥ ÿØÿßÿØŸá ÿ¥ÿØŸá ÿßÿ≥ÿ™.
2Ô∏è‚É£ ÿ±Ÿà€å Confirm ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ.
"""
        ]  

    # Construct caption with current index and total number of photos
    caption = captions_list[current_index_linea_surge_unstake]

    # Construct InlineKeyboardMarkup based on current message index
    buttons = []
    if current_index_linea_surge_unstake == 0:
        buttons = [
                [InlineKeyboardButton("‚û°Ô∏è ÿ®ÿπÿØ€å", callback_data=str(current_index_linea_surge_unstake + 1))],
                [InlineKeyboardButton("ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿß€åÿ±ÿØÿ±ÿßŸæ ŸÑ€åŸÜ€åÿß üè†‚¨ÖÔ∏è ", callback_data="air_drop_linea_surge_menu_over")]
    ]
    elif current_index_linea_surge_unstake == len(os.listdir(img_add)) - 1:
        buttons = [
                [InlineKeyboardButton("üéâü•≥ ÿ™ÿßŸÖÿßŸÖ!", callback_data="air_drop_linea_surge_menu_over")],
                [InlineKeyboardButton("ŸÇÿ®ŸÑ€å ‚¨ÖÔ∏è", callback_data=str(current_index_linea_surge_unstake - 1))]
    ]
    else:
        buttons = [
                [InlineKeyboardButton("ŸÇÿ®ŸÑ€å ‚¨ÖÔ∏è", callback_data=str(current_index_linea_surge_unstake - 1)),
                 InlineKeyboardButton("‚û°Ô∏è ÿ®ÿπÿØ€å", callback_data=str(current_index_linea_surge_unstake + 1))]
        ]

    reply_markup = InlineKeyboardMarkup(buttons)

    # Send the current photo with caption and navigation buttons
    chat_id = update.effective_chat.id

    with open(image_filename, 'rb') as photo:
        sent_photo = await context.bot.send_photo(
            chat_id=chat_id,
            photo=photo,
            caption=caption,
            reply_markup=reply_markup
        )

        # Store the message ID
        if chat_id not in message_ids:
            # initialize a list to store further information
            message_ids[chat_id] = []
        message_ids[chat_id].append(sent_photo.message_id)

        # Delete the previous photo if it exists
        
        # Use.get() method to avoid KeyError if chat_id not found
        if len(message_ids.get(chat_id, [])) > 1:
            await context.bot.delete_message(chat_id=chat_id, message_id=message_ids[chat_id][0])
            message_ids[chat_id].pop(0)

    return LINEA_SURGE_AIRDROP_UNSTAKE


async def air_drop_linea_surge_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    global chat_id

    # Delete the previous photo if it exists
    if len(message_ids.get(chat_id, [])) == 1: # Use.get() method to avoid KeyError if chat_id not found
        await context.bot.delete_message(chat_id=chat_id, message_id=message_ids[chat_id][0])
        message_ids[chat_id].pop(0)

    global current_index_linea_surge_stake, first_time_loop_linea_surge_stake
    current_index_linea_surge_stake = 0
    first_time_loop_linea_surge_stake = True

    global current_index_linea_surge_unstake, first_time_loop_linea_surge_unstake
    current_index_linea_surge_unstake = 0
    first_time_loop_linea_surge_unstake = True


    keyboard = [
        [InlineKeyboardButton("1. Ÿàÿßÿ±€åÿ≤ ⁄©ÿ±ÿØŸÜ (Stake) üíµüí∞", callback_data="linea_surge_stake")],
        [InlineKeyboardButton("2. ÿ®ÿ±ÿØÿßÿ¥ÿ™ ⁄©ÿ±ÿØŸÜ (Unstake) üíµüí∞", callback_data="linea_surge_unstake")],
        [InlineKeyboardButton("ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ‚¨ÖÔ∏è", callback_data="back_to_air_drop_menu")]
    ]
    key_markup = InlineKeyboardMarkup(keyboard)

    text = """
<b>ÿß€åÿ±ÿØÿ±ÿßŸæ ŸÅÿßŸÜÿ™ŸàŸÖ (Phantom) </b>

üîÑ ŸÜÿ≠ŸàŸá ŸÅÿπÿßŸÑ€åÿ™: 
ŸáŸÅÿ™⁄Ø€å €åÿß ŸÖÿßŸá€åÿßŸÜŸá

üíµ ŸÖŸàÿ¨ŸàÿØ€å ŸÖŸàÿ±ÿØ ŸÜ€åÿßÿ≤:
30 ÿ™ÿ™ÿ± 

üì∞ Ÿàÿ∂ÿπ€åÿ™ ÿß€åÿ±ÿØÿ±ÿßŸæ:
ÿßÿ≠ÿ™ŸÖÿßŸÑ€å

üìÖ ÿ™ÿßÿ±€åÿÆ ÿ™Ÿàÿ≤€åÿπ: 
ŸÜÿßŸÖÿ¥ÿÆÿµ

üìñ ÿ™Ÿàÿ∂€åÿ≠ÿßÿ™:
ÿ®ÿ±ÿß€å ÿ¥ÿ±⁄©ÿ™ ÿØÿ± ÿß€åÿ±ÿØÿ±ÿßŸæ ŸÅÿßŸÜÿ™ŸàŸÖÿå ŸÑÿ∑ŸÅÿßŸã ŸÖŸàÿßÿ±ÿØ ÿ≤€åÿ± ÿ±ÿß ÿ®Ÿá ÿ™ÿ±ÿ™€åÿ® ÿßŸÜÿ¨ÿßŸÖ ÿØŸá€åÿØ.
"""

    # Select an image to send
    # Replace with the actual path to your image
    image_filename = os.path.join('img', 'airdrop', 'linea_surge', 'linea_surge.png')

    # Send the image along with the text and buttons
    await context.bot.send_photo(
        chat_id=update.effective_chat.id,
        photo=open(image_filename, 'rb'),
        caption=text,
        reply_markup=key_markup,
        parse_mode="HTML"
    )

    return LINEA_SURGE_AIRDROP


async def air_drop_linea_surge_menu_over(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    global chat_id

    # Delete the previous photo if it exists
    if len(message_ids.get(chat_id, [])) == 1: # Use.get() method to avoid KeyError if chat_id not found
        await context.bot.delete_message(chat_id=chat_id, message_id=message_ids[chat_id][0])
        message_ids[chat_id].pop(0)

    return LINEA_SURGE_AIRDROP

### <<<-------------------------------------------- Scroll AirDrop -------------------------------------------->>> ###

### <<<-------------------------------------------- Blast AirDrop -------------------------------------------->>> ###

### <<<-------------------------------------------- Sound AirDrop -------------------------------------------->>> ###

### <<<-------------------------------------------- Phaver AirDrop -------------------------------------------->>> ###

### <<<-------------------------------------------- Lens AirDrop -------------------------------------------->>> ###


async def air_drop_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    global current_index_ph_swap, first_time_loop_ph_swap
    current_index_ph_swap = 0
    first_time_loop_ph_swap = True

    global current_index_ph_stake, first_time_loop_ph_stake
    current_index_ph_stake = 0
    first_time_loop_ph_stake = True

    global current_index_ph_unstake, first_time_loop_ph_unstake
    current_index_ph_unstake = 0
    first_time_loop_ph_unstake = True

    keyboard = [
        [InlineKeyboardButton("ÿß€åÿ±ÿØÿ±ÿßŸæ ŸÅÿßŸÜÿ™ŸàŸÖ (Phantom)", callback_data="air_drop_phantom_menu"),
         InlineKeyboardButton("ÿß€åÿ±ÿØÿ±ÿßŸæ ŸÑ€åŸÜ€åÿß ÿ≥ÿ±ÿ¨ (Linea Surge)", callback_data="air_drop_linea_surge_menu")],
        [InlineKeyboardButton("ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å üè† ", callback_data="main_menu")]
    ]
    key_markup = InlineKeyboardMarkup(keyboard)

    text = """
ŸÑÿ∑ŸÅÿßŸã ÿ®ÿ±ÿß€å ÿ¥ÿ±⁄©ÿ™ ÿØÿ± Ÿáÿ± ÿß€åÿ±ÿØÿ±ÿßŸæÿå ÿ±Ÿà€å ÿØ⁄©ŸÖŸá ŸÖŸàÿ±ÿØ ŸÜÿ∏ÿ± ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ.
ÿ™Ÿàÿ∂€åÿ≠ÿßÿ™ ŸÖÿ±ÿ®Ÿàÿ∑ ÿ®Ÿá ŸÜÿ≠ŸàŸá ÿ¥ÿ±⁄©ÿ™ ÿØÿ± Ÿáÿ± €å⁄© ÿßÿ≤ ÿß€åÿ±ÿØÿ±ÿßŸæ‚ÄåŸáÿß ÿ®ÿ±ÿß€å ÿ¥ŸÖÿß ŸÜŸÖÿß€åÿ¥ ÿØÿßÿØŸá ÿÆŸàÿßŸáÿØ ÿ¥ÿØ.
"""

    if query.message and query.message.text:
        try:
            await query.edit_message_text(text=text, reply_markup=key_markup)
        except BadRequest:
            await query.message.reply_text(text=text, reply_markup=key_markup)
    else:
        await query.message.reply_text(text=text, reply_markup=key_markup)

    return START_ROUTES



### <<<------------------------------------------------------------------------------------------------------->>> ###
### <<<------------------------------------------------------------------------------------------------------->>> ###
### <<<-------------------------------------------- Main Function -------------------------------------------->>> ###
### <<<------------------------------------------------------------------------------------------------------->>> ###
### <<<------------------------------------------------------------------------------------------------------->>> ###

def main() -> None:
    """Run the bot."""
    # Create the Application and pass it your bot's token.
    application = Application.builder().token(Tk).build()

    conv_handler = ConversationHandler(
        entry_points=[CommandHandler("start", start)],
        states={
            START_ROUTES: [
                CallbackQueryHandler(submit_email, pattern="^" + "submit_email" + "$"),
                CallbackQueryHandler(local_exchange, pattern="^" + "local_exchange" + "$"),
                CallbackQueryHandler(global_exchange, pattern="^" + "global_exchange" + "$"),
                CallbackQueryHandler(main_menu, pattern="^" + "main_menu" + "$"),
                CallbackQueryHandler(air_drop_menu, pattern="^" + "air_drops" + "$"),
                CallbackQueryHandler(air_drop_phantom_menu, pattern="^" + "air_drop_phantom_menu" + "$"),
                CallbackQueryHandler(air_drop_linea_surge_menu, pattern="^" + "air_drop_linea_surge_menu" + "$")
            ],
            END_ROUTES: [
                CallbackQueryHandler(start_over, pattern="^" + "main_menu" + "$")
            ],
            SEND_IMG: [
                CallbackQueryHandler(air_drop_menu, pattern="^" + "back_to_air_drop_menu" + "$")
            ],
            PH_AIRDROP: [ 
                CallbackQueryHandler(air_drop_phantom_swap, pattern="^" + "phantom_swap" + "$"),
                CallbackQueryHandler(air_drop_phantom_stake, pattern="^" + "phantom_stake" + "$"),
                CallbackQueryHandler(air_drop_phantom_unstake, pattern="^" + "phantom_unstake" + "$"),
                CallbackQueryHandler(air_drop_menu, pattern="^" + "back_to_air_drop_menu" + "$")
            ],
            PH_AIRDROP_SWAP: [ 
                CallbackQueryHandler(air_drop_phantom_swap, pattern="^(\d+)$"),
                CallbackQueryHandler(air_drop_phantom_menu_over, pattern="^" + "air_drop_phantom_menu_over" + "$")
            ],
            PH_AIRDROP_STAKE: [ 
                CallbackQueryHandler(air_drop_phantom_stake, pattern="^(\d+)$"),
                CallbackQueryHandler(air_drop_phantom_menu_over, pattern="^" + "air_drop_phantom_menu_over" + "$")
            ],
            PH_AIRDROP_UNSTAKE: [ 
                CallbackQueryHandler(air_drop_phantom_unstake, pattern="^(\d+)$"),
                CallbackQueryHandler(air_drop_phantom_menu_over, pattern="^" + "air_drop_phantom_menu_over" + "$")
            ],
            LINEA_SURGE_AIRDROP: [ 
                CallbackQueryHandler(air_drop_linea_surge_stake, pattern="^" + "linea_surge_stake" + "$"),
                CallbackQueryHandler(air_drop_linea_surge_unstake, pattern="^" + "linea_surge_unstake" + "$"),
                CallbackQueryHandler(air_drop_menu, pattern="^" + "back_to_air_drop_menu" + "$")
            ],
            LINEA_SURGE_AIRDROP_STAKE: [ 
                CallbackQueryHandler(air_drop_linea_surge_stake, pattern="^(\d+)$"),
                CallbackQueryHandler(air_drop_linea_surge_menu_over, pattern="^" + "air_drop_linea_surge_menu_over" + "$")
            ],
            LINEA_SURGE_AIRDROP_UNSTAKE: [ 
                CallbackQueryHandler(air_drop_linea_surge_unstake, pattern="^(\d+)$"),
                CallbackQueryHandler(air_drop_linea_surge_menu_over, pattern="^" + "air_drop_linea_surge_menu_over" + "$")
            ],
            EMAIL: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, confirm_email)
            ]
        },
        fallbacks=[CommandHandler("start", start)],
    )

    # Add ConversationHandler to application that will be used for handling updates
    application.add_handler(conv_handler)

    # Run the bot until the user presses Ctrl-C
    application.run_polling(
        allowed_updates=Update.ALL_TYPES, poll_interval=3, timeout=60
    )

### <<<------------------------------------------------------------------------------------------------------------>>> ###
### <<<------------------------------------------------------------------------------------------------------------>>> ###
### <<<-------------------------------------------- Initiation The Bot -------------------------------------------->>> ###
### <<<------------------------------------------------------------------------------------------------------------>>> ###
### <<<------------------------------------------------------------------------------------------------------------>>> ###

# Load the email_ids dictionary when the bot starts
data_base = load_data_base()

print('Starting up bot...')

Tk = config('token')

if __name__ == "__main__":
    main()
